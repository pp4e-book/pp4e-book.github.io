<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    
    <title>2. A Broad Look at Programming and Programming Languages &#8212; Programming with Python for Engineers 0.0.1 documentation</title>

    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/d2l.css" />
    <link rel="stylesheet" href="../_static/material-design-lite-1.3.0/material.blue-deep_orange.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx_materialdesign_theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/fontawesome/all.css" type="text/css" />
    <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/d2l.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3. Representation of Data" href="ch3_data_representation.html" />
    <link rel="prev" title="1. Basic Computer Organization" href="ch1_computer_organization.html" /> 
  </head>
<body>
    <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header mdl-layout--fixed-drawer"><header class="mdl-layout__header mdl-layout__header--waterfall ">
    <div class="mdl-layout__header-row">
        
        <nav class="mdl-navigation breadcrumb">
            <a class="mdl-navigation__link is-active"><span class="section-number">2. </span>A Broad Look at Programming and Programming Languages</a>
        </nav>
        <div class="mdl-layout-spacer"></div>
        <nav class="mdl-navigation">
        
<form class="form-inline pull-sm-right" action="../search.html" method="get">
      <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right">
        <label id="quick-search-icon" class="mdl-button mdl-js-button mdl-button--icon"  for="waterfall-exp">
          <i class="material-icons">search</i>
        </label>
        <div class="mdl-textfield__expandable-holder">
          <input class="mdl-textfield__input" type="text" name="q"  id="waterfall-exp" placeholder="Search" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </div>
      </div>
      <div class="mdl-tooltip" data-mdl-for="quick-search-icon">
      Quick search
      </div>
</form>
        
<a id="button-show-source"
    class="mdl-button mdl-js-button mdl-button--icon"
    href="../_sources/chapters/ch2_programming.rst.txt" rel="nofollow">
  <i class="material-icons">code</i>
</a>
<div class="mdl-tooltip" data-mdl-for="button-show-source">
Show Source
</div>
        </nav>
    </div>
    <div class="mdl-layout__header-row header-links">
      <div class="mdl-layout-spacer"></div>
      <nav class="mdl-navigation">
          
              <a  class="mdl-navigation__link" href="https://pp4e-book.github.io/pp4e-book.pdf">
                  <i class="fas fa-file-pdf"></i>
                  PDF
              </a>
          
              <a  class="mdl-navigation__link" href="https://github.com/pp4e-book/source">
                  <i class="fab fa-github"></i>
                  Github
              </a>
          
              <a  class="mdl-navigation__link" href="https://pp4e-book.github.io/chapters/all_notebooks.zip">
                  <i class="fas fa-download"></i>
                  All Notebooks
              </a>
          
              <a  class="mdl-navigation__link" href="https://ceng240.github.io/">
                  <i class="fas fa-user-graduate"></i>
                  Course
              </a>
      </nav>
    </div>
</header><header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../index.html">
              <img class="logo" src="../_static/logo-with-text.png" alt="Programming with Python for Engineers"/>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul>
<li class="toctree-l1"><a class="reference internal" href="ch0_preface.html">Preface</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ch1_computer_organization.html">1. Basic Computer Organization</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">2. A Broad Look at Programming and Programming Languages</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch3_data_representation.html">3. Representation of Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch4_dive_into_python.html">4. Dive into Python</a></li>
</ul>

            </nav>
        
        </div>
    
</header>
        <main class="mdl-layout__content" tabIndex="0">

	<script type="text/javascript" src="../_static/sphinx_materialdesign_theme.js "></script>
    <header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../index.html">
              <img class="logo" src="../_static/logo-with-text.png" alt="Programming with Python for Engineers"/>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul>
<li class="toctree-l1"><a class="reference internal" href="ch0_preface.html">Preface</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ch1_computer_organization.html">1. Basic Computer Organization</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">2. A Broad Look at Programming and Programming Languages</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch3_data_representation.html">3. Representation of Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch4_dive_into_python.html">4. Dive into Python</a></li>
</ul>

            </nav>
        
        </div>
    
</header>

    <div class="document">
        <div class="page-content" role="main">
        
  <div class="section" id="a-broad-look-at-programming-and-programming-languages">
<span id="ch2"></span><h1><span class="section-number">2. </span>A Broad Look at Programming and Programming Languages<a class="headerlink" href="#a-broad-look-at-programming-and-programming-languages" title="Permalink to this headline">¶</a><a href="https://colab.research.google.com/github/pp4e-book/pp4e-book.github.io/blob/master/chapters/ch2_programming.ipynb" onclick="captureOutboundLink('https://colab.research.google.com/github/['pp4e-book/pp4e-book.github.io']/blob/master/chapters/ch2_programming.ipynb'); return false;"> <button style="float:right", id="Colab" class="mdl-button mdl-js-button mdl-button--primary mdl-js-ripple-effect"> <i class=" fas fa-external-link-alt"></i> Colab </button></a><div class="mdl-tooltip" data-mdl-for="Colab"> Open the notebook in Colab</div></h1>
<p>The previous chapter provided a closer look at how a modern computer
works. In this chapter, we will first look at how we generally solve
problems with such computers. Then, we will see that a programmer does
not have to control a computer using the binary machine code
instructions we introduced in the previous chapter: We can use
human-readable instructions and languages to make things easy for
programming.</p>
<div class="section" id="how-do-we-solve-problems-with-programs">
<h2><span class="section-number">2.1. </span>How do we solve problems with programs?<a class="headerlink" href="#how-do-we-solve-problems-with-programs" title="Permalink to this headline">¶</a></h2>
<p>The von Neumann machine, on which computers’ design is based, makes a
clear distinction between instruction and data (do not get confused by
the machine code holding both data and instructions: The data field in
such instructions are generally addresses of the data to be manipulated
and therefore, data and instructions exist as different entities in
memory). Due to this clear distinction between data and instruction, the
solutions to world problems were approached and handled with this
distinction in mind (<a class="reference internal" href="#fig-ch2-solving-world-problems"><span class="std std-numref">Fig. 2.1.1</span></a>):</p>
<blockquote>
<div><p><em>“For solving world problems, the first task of the programmer is to
identify the information to be processed to solve the problem. This
information is called data. Then, the programmer has to find an
action schema that will act upon this data, carry out those actions
according to the plan, and produce a solution to the problem. This
well-defined action schema is called an algorithm.”</em></p>
<p>[From: <a class="reference external" href="https://link.springer.com/book/10.1007/978-3-7091-1343-1">G. Üçoluk, S. Kalkan, Introduction to Programming Concepts
with Case Studies in Python, Springer,
2012</a>]</p>
</div></blockquote>
<div class="figure align-default" id="id1">
<span id="fig-ch2-solving-world-problems"></span><a class="reference internal image-reference" href="../_images/ch2_solving_world_problems.png"><img alt="../_images/ch2_solving_world_problems.png" src="../_images/ch2_solving_world_problems.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-number">Fig. 2.1.1 </span><span class="caption-text">Solving a world problem with a computer requires first designing how
the data is going to be represented and specifying the steps which
yield the solution when executed on the data. This design of the
solution is then written (implemented) in a programming language to
be executed as a program such that, when executed, the program
outputs the solution for the world problem. [From: <a class="reference external" href="https://link.springer.com/book/10.1007/978-3-7091-1343-1">G. Üçoluk, S.
Kalkan, Introduction to Programming Concepts with Case Studies in
Python, Springer,
2012</a>]</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="algorithm">
<h2><span class="section-number">2.2. </span>Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this headline">¶</a></h2>
<p>An algorithm is a step-by-step procedure that, when executed, leads to
an output for the input we provided. If the procedure was correct, we
expect the output to be the desired output, i.e. the solution we wanted
for the algorithm to compute.</p>
<p>Algorithms can be thought of as recipes for cooking. This analogy makes
sense since we would define a recipe as a step-by-step procedure for
cooking something: Each step performs a little action (cutting, slicing,
stirring etc.) that brings us closer to the outcome, the meal.</p>
<p>This is exactly the case in algorithms as well: At each step, we make a
small progress towards the solution by performing a small computation
(e.g. adding numbers, finding the minimum of a set of real numbers
etc.). The only difference with cooking is that each step needs to be
<em>understandable</em> by the computer; otherwise, it is not an algorithm.</p>
<center><table align="center" width="100%" style="word-wrap:break-word; table-layout:fixed; width:150px"><tr><td style="vertical-align: top; max-width:150px"><p>The origins of the world ‘algorithm’ The word ‘algorithm’ comes from the
Latin word <em>algorithmi</em>, which is the Latinized name of Al-Khwarizmi.
Al-Khwarizmi was a Persian Scientist who has written a book on algebra
titled “The Compendious Book on Calculation by Completion and Balancing”
during 813–833 which presented the first systematic solution of linear
and quadratic equations. His contributions established algebra, which
stems from his method of “al-jabr” (meaning “completion” or
“rejoining”). The reason the world algorithm is attributed to
Al-Khwarizmi is because he proposed systematic methods for solving
equations using sequences of well-defined instructions (e.g. “take all
variables to the right. divide the coefficients by the coefficient of
x…”) – i.e. using what we call today as algorithms.</p>
</td><td><div class="figure align-default" id="id2">
<span id="fig-al-khwarizmi"></span><a class="reference internal image-reference" href="../_images/ch2_al-khwarizmi.jpg"><img alt="../_images/ch2_al-khwarizmi.jpg" src="../_images/ch2_al-khwarizmi.jpg" style="width: 200px;" /></a>
<p class="caption"><span class="caption-number">Fig. 2.2.1 </span><span class="caption-text">Muhammad ibn Musa al-Khwarizmi (c. 780 – c. 850)</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
</td></tr></table></center><p>** Are algorithms the same thing as programs? **</p>
<p>It is very natural to confuse algorithms with programs as they are both
step-by-step procedures. However, algorithms can be studied and they
were invented long before there were computers or programming languages.
We can design and study algorithms without using computers with just a
pen and paper. A program, on the other hand, is just an implementation
of an algorithm in a programming language. In other words, algorithms
are designs and programs are the written forms of these designs in
programming languages.</p>
<div class="section" id="how-to-write-algorithms">
<h3><span class="section-number">2.2.1. </span>How to write algorithms<a class="headerlink" href="#how-to-write-algorithms" title="Permalink to this headline">¶</a></h3>
<p>As we have discussed above, before programming our solution, we first
need to design it. While designing an algorithm, we generally use two
mechanisms:</p>
<ol class="arabic simple">
<li><p><strong>Pseudo-codes</strong>. Pseudo-codes are natural language descriptions of
the steps that need to be followed in the algorithm. It is not as
specific or restricted as a programming language but it is not as
free as the language we use for communicating with other humans: A
pseudo-code should be composed of precise and feasible steps and
avoid ambiguous descriptions.</p></li>
</ol>
<p>Here is an example pseudo-code:</p>
<p><em>Algorithm 1. Calculate the average of numbers provided by the user.</em></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">N</span> <span class="o">--</span> <span class="n">the</span> <span class="n">count</span> <span class="n">of</span> <span class="n">numbers</span>
<span class="n">Output</span><span class="p">:</span> <span class="n">The</span> <span class="n">average</span> <span class="n">of</span> <span class="n">N</span> <span class="n">numbers</span> <span class="n">to</span> <span class="n">be</span> <span class="n">provided</span>
<span class="n">Step</span> <span class="mi">1</span><span class="p">:</span> <span class="n">Get</span> <span class="n">how</span> <span class="n">many</span> <span class="n">numbers</span> <span class="n">will</span> <span class="n">be</span> <span class="n">provided</span> <span class="ow">and</span> <span class="n">store</span> <span class="n">that</span> <span class="ow">in</span> <span class="n">N</span>
<span class="n">Step</span> <span class="mi">2</span><span class="p">:</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">variable</span> <span class="n">named</span> <span class="n">Result</span> <span class="k">with</span> <span class="n">initial</span> <span class="n">value</span> <span class="mi">0</span>
<span class="n">Step</span> <span class="mi">3</span><span class="p">:</span> <span class="n">Execute</span> <span class="n">the</span> <span class="n">following</span> <span class="n">step</span> <span class="n">N</span> <span class="n">times</span><span class="p">:</span>
<span class="n">Step</span> <span class="mi">4</span><span class="p">:</span>    <span class="n">Get</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">number</span> <span class="ow">and</span> <span class="n">add</span> <span class="n">it</span> <span class="n">to</span> <span class="n">Result</span>
<span class="n">Step</span> <span class="mi">5</span><span class="p">:</span> <span class="n">Divide</span> <span class="n">Result</span> <span class="n">by</span> <span class="n">N</span> <span class="n">to</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">average</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p><strong>Flowcharts</strong>. As an alternative to pseudocodes, we can use
flowcharts while designing algorithms. Flowcharts are diagrams
composed of small computational elements that describe the steps of
the algorithm. An example in <a class="reference internal" href="#fig-ch2-flowchart"><span class="std std-numref">Fig. 2.2.2</span></a>
illustrates what kind of elements are used and how they are brought
together to describe an algorithm.</p></li>
</ol>
<p>Flowcharts can be more intuitive to work with. However, for complex
algorithms, flowcharts can get very large and prohibitive to work with.</p>
<div class="figure align-default" id="id3">
<span id="fig-ch2-flowchart"></span><a class="reference internal image-reference" href="../_images/ch2_flowchart_example.png"><img alt="../_images/ch2_flowchart_example.png" src="../_images/ch2_flowchart_example.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 2.2.2 </span><span class="caption-text">Flowcharts describe relationships by using basic geometric symbols
and arrows. The program start or end is depicted with an oval. A
rectangular box denotes a simple action or status. Decision making is
represented by a diamond and a parallelogram of the Input/Output
process. A silhouette of a TV tube means displaying a message. The
Internet is portrayed as a cloud.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="how-to-compare-algorithms">
<h3><span class="section-number">2.2.2. </span>How to compare algorithms<a class="headerlink" href="#how-to-compare-algorithms" title="Permalink to this headline">¶</a></h3>
<p>If two algorithms find the same solution, are they of the same quality?
For a second, recall a game we used to play when we were in primary
school: “Guess My Number”.</p>
<p>The rule is as follows: There is a setter and a guesser. The setter sets
a number from 1 to 1000 which s/he does not tell. The guesser has to
find this number. At each turn of the game, the guesser can propose any
number from 1 to 1000. The setter answers by one of following:</p>
<ul class="simple">
<li><p><strong>HIT:</strong> The guesser found the number.</p></li>
<li><p><strong>LESSER:</strong> The hidden number is less than the proposed one.</p></li>
<li><p><strong>GREATER:</strong> The hidden number is greater than the proposed one.</p></li>
</ul>
<p>In how many turns the number is found is recorded. The guesser and the
setter switch. This goes on for some agreed count of rounds. Whoever has
a lower total count of turns wins.</p>
<p>Many of you have played this game and certainly have observed that there
are three categories of children:</p>
<ol class="arabic">
<li><p><em>Random guessers:</em> Worst category. Usually they cannot keep track of
the answers and just based on the last answer, they randomly utter a
number that comes to their mind. Quite possibly they repeat
themselves.</p></li>
<li><p>Sweepers: They start at either 1 or 1000, and then systematically
increase or decrease their proposal, e.g.:</p>
<ul class="simple">
<li><p><em>-is it 1000?</em> Answer: LESSER</p></li>
<li><p><em>-is it 999?</em> Answer: LESSER</p></li>
<li><p>-<em>is it 998?</em> Answer: LESSER</p></li>
</ul>
<p>… and so on. Certainly at some point such players do get a HIT. There
is a group which decreases the number by two or three as well. With a
first GREATER reply, they start to increment by one.</p>
</li>
<li><p><em>Middle seekers:</em> Keeping a possible lower and a possible upper value
based on the reply they got, at every stage they propose the number
just in the middle of lower and upper values, e.g.:</p>
<ul class="simple">
<li><p><em>-is it 500?</em> Answer: LESSER</p></li>
<li><p><em>-is it 250?</em> Answer: LESSER</p></li>
<li><p>-<em>is it 125?</em> Answer: GREATER</p></li>
<li><p>-<em>is it 187? (which was (125+250)/2)</em> Answer: GREATER</p></li>
<li><p>… and so on.</p></li>
</ul>
</li>
</ol>
<p>All three categories actually adopt different algorithms, which will
find the answer in the end. However, as you may have realised even as
you were a child, the first group performs the worst, then comes the
second group. The third group, if they do not make mistakes, is
unbeatable.</p>
<p>In other words, algorithms that aim to solve the same problem may not be
of the same “quality”: Some perform better. This is the case for all
algorithms and one of the challenges in Computer Science is to find
“better” algorithms. But, what is “better”? Is there a quantitative
measure for “better”ness? The answer is yes.</p>
<p>Let us look at this in the child game described above. First consider
the last group’s algorithm (the middle seekers). At every turn, this
kind of seeker narrows down the search space by a factor of 1/2.
Starting with 1000 numbers, the search space is reduced as follows:
<span class="math notranslate nohighlight">\(1000\)</span>, <span class="math notranslate nohighlight">\(1000/2\)</span>, <span class="math notranslate nohighlight">\(1000/2^2\)</span>, … So, in the worst case,
it will take <span class="math notranslate nohighlight">\(m\)</span> turns until <span class="math notranslate nohighlight">\(1000/2^m\)</span> gets down to 1 (the
one remaining number, which has to be the hidden number). In other
words, in the worst case, <span class="math notranslate nohighlight">\(1000/2^m=1\)</span> and from this we can derive
<span class="math notranslate nohighlight">\(m=\log_2(1000)\)</span>. For 1000, this means approximately <span class="math notranslate nohighlight">\(m=10\)</span>
turns. If we double the range, <span class="math notranslate nohighlight">\(m\)</span> would change only by 1 (yes,
think about it, only 11 turns).</p>
<p>We call such an algorithm of “order log(n)” or more technically,
<span class="math notranslate nohighlight">\(\cal{O}(\log(n))\)</span>. In our case 1000 determines the ‘size’ of the
problem. This is symbolized with <span class="math notranslate nohighlight">\(n\)</span>. <span class="math notranslate nohighlight">\(\cal{O}(\log(n))\)</span> is
the quantitative information about the algorithm which signifies that
the solution time is proportional to <span class="math notranslate nohighlight">\(\log(n)\)</span>. This information
about an algorithm is named as <em>complexity</em>.</p>
<p>What about the sweepers algorithm for the problem above? In the worst
case, the sweeper would ask a question 1000 times (the correct number is
at the other end of the sequence). If the size (1000 in our case) is
symbolized with <span class="math notranslate nohighlight">\(n\)</span>, then it will take a time proportional to
<span class="math notranslate nohighlight">\(n\)</span> to reach the solution. In other words this algorithm’s
complexity is <span class="math notranslate nohighlight">\(\cal{O}(n)\)</span>.</p>
<p>Certainly the algorithm that has <span class="math notranslate nohighlight">\(\cal{O}(\log(n))\)</span> is better than
the one with <span class="math notranslate nohighlight">\(\cal{O}(n)\)</span>, which is illustrated in
<a class="reference internal" href="#fig-ch2-various-complexities"><span class="std std-numref">Fig. 2.2.3</span></a>. In other words, an
<span class="math notranslate nohighlight">\(\cal{O}(\log(n))\)</span> algorithm requires less number of steps and is
likely to run faster than the one with <span class="math notranslate nohighlight">\(\cal{O}(n)\)</span> complexity.</p>
<div class="figure align-default" id="id4">
<span id="fig-ch2-various-complexities"></span><img alt="../_images/ch2_various_complexities.png" src="../_images/ch2_various_complexities.png" />
<p class="caption"><span class="caption-number">Fig. 2.2.3 </span><span class="caption-text">A plot of various complexities.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="data-representation">
<h2><span class="section-number">2.3. </span>Data Representation<a class="headerlink" href="#data-representation" title="Permalink to this headline">¶</a></h2>
<p>The other crucial component of our solutions to world problems is the
data representation, which deals with encoding the information regarding
the problem in a form that is most suitable for our algorithm.</p>
<p>If our problem is the calculation of the average of grades in a class,
then before implementing our solution, we need to determine how we are
going to represent (encode) the grades of students. This is what we are
going to determine in the ‘data representation’ part of our solution and
to discuss in Chapter 3.</p>
</div>
<div class="section" id="the-world-of-programming-languages">
<h2><span class="section-number">2.4. </span>The World of Programming Languages<a class="headerlink" href="#the-world-of-programming-languages" title="Permalink to this headline">¶</a></h2>
<p>Since the advent of computers, many programming languages have been
developed with different designs and levels of complexity. In fact,
there are about 700 programming languages - see, e.g. <a class="reference external" href="https://en.wikipedia.org/wiki/List_of_programming_languages_by_type">the list of
programming
languages</a>
- that offer different abstraction levels (hiding the low-level details
from the programmer) and computational benefits (e.g. providing built-in
rule-search engine).</p>
<p>In this section, we will give a flavour of programming languages in
terms of abstraction levels (low-level vs. high-level – see
<a class="reference internal" href="#fig-ch2-spectrum-of-pl"><span class="std std-numref">Fig. 2.4.1</span></a>) as well as the computational
benefits they provide.</p>
<div class="figure align-default" id="id5">
<span id="fig-ch2-spectrum-of-pl"></span><img alt="../_images/ch2_spectrum_of_PL.png" src="../_images/ch2_spectrum_of_PL.png" />
<p class="caption"><span class="caption-number">Fig. 2.4.1 </span><span class="caption-text">The spectrum of programming languages, ranging from low-level
languages to high-level languages and natural languages.</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="low-level-languages">
<h3><span class="section-number">2.4.1. </span>Low-level Languages<a class="headerlink" href="#low-level-languages" title="Permalink to this headline">¶</a></h3>
<p>In the previous chapter, we introduced the concept of machine code
program. A machine code program is an aggregate of instructions and
data, all being represented in terms of zeros (0) and ones (1). A
machine code is practically unreadable and very burdensome to create, as
we have seen before and illustrated below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">01010101</span> <span class="mi">01001000</span> <span class="mi">10001001</span> <span class="mi">11100101</span> <span class="mi">10001011</span> <span class="mi">00010101</span> <span class="mi">10110010</span> <span class="mi">00000011</span>
<span class="mi">00100000</span> <span class="mi">00000000</span> <span class="mi">10001011</span> <span class="mi">00000101</span> <span class="mi">10110000</span> <span class="mi">00000011</span> <span class="mi">00100000</span> <span class="mi">00000000</span>
<span class="mi">00001111</span> <span class="mi">10101111</span> <span class="mi">11000010</span> <span class="mi">10001001</span> <span class="mi">00000101</span> <span class="mi">10111011</span> <span class="mi">00000011</span> <span class="mi">00100000</span>
<span class="mi">00000000</span> <span class="mi">10111000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">11001001</span> <span class="mi">11000011</span>
<span class="o">...</span>
<span class="mi">11001000</span> <span class="mi">00000001</span> <span class="mi">00000000</span> <span class="mi">00000000</span>  <span class="mi">00000000</span> <span class="mi">00000000</span>
</pre></div>
</div>
<p>To overcome this, <em>assembly</em> language and assemblers were invented. An
assembler is a machine code program that serves as a translator from
some relatively more readable text, the assembly program, into machine
code. The key feature of an assembler is that each line of an assembly
program corresponds exactly to a single machine code instruction. As an
example, the binary machine code above can be written in an assembly
language as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>main:
       pushq   %rbp
       movq    %rsp, %rbp
       movl    alice(%rip), %edx
       movl    bob(%rip), %eax
       imull   %edx, %eax
       movl    %eax, carol(%rip)
       movl    $0, %eax
       leave
       ret
alice:
       .long   123
bob:
       .long   456
</pre></div>
</div>
<p><strong>Pros of assembly</strong>:</p>
<ul class="simple">
<li><p>Instructions and registers have human recognizable mnemonic words
associated. Like integer addition instruction being <code class="docutils literal notranslate"><span class="pre">ADDI</span></code>, for
example.</p></li>
<li><p>Numerical constants can be written down in human readable, base-10
format, the assembler does the conversion to internal format.</p></li>
<li><p>Implements naming of memory positions that hold data. In other words,
assembly has a primitive implementation of the variable concept.</p></li>
</ul>
<p><strong>Cons of assembly</strong>:</p>
<ul class="simple">
<li><p>No arithmetic or logical expressions.</p></li>
<li><p>No concept of functions.</p></li>
<li><p>No concept of statement grouping.</p></li>
<li><p>No concept of data containers.</p></li>
</ul>
</div>
<div class="section" id="high-level-languages">
<h3><span class="section-number">2.4.2. </span>High-level Languages<a class="headerlink" href="#high-level-languages" title="Permalink to this headline">¶</a></h3>
<p>To overcome the limitations of binary machine codes and the assembly
language, more capable <em>Programming Languages</em> were developed. We call
these languages <em>High-level languages</em>. These languages hide the
low-level details of the computer (and the CPU) and allow a programmer
to write code in a more human-readable form.</p>
<p>A high-level programming language (or an assembly language) is defined,
similar to a natural language, by syntax (a set of grammar rules
governing how to bring together words) and semantics (the meaning –
i.e. what is meant by the sequences of words in the syntax) associated
for the syntax. The syntax is based on keywords from a human language
(due to historical reasons, English). Using human-readable keywords ease
comprehension.</p>
<p>The following example is a program expressed in Python that asks for a
Fahrenheit value and prints its conversion into Celsius:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Fahrenheit =  input(&quot;Please Enter Fahrenheit value:&quot;)
print(&quot;Celsius equivalent is:&quot;, (Fahrenheit − 32) * 5/9)
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">input</span></code> and <code class="docutils literal notranslate"><span class="pre">print</span></code> are keywords of the language. Their
semantics is self explanatory. <code class="docutils literal notranslate"><span class="pre">Fahrenheit</span></code> is a naming we have chosen
for a variable that will hold the input value.</p>
<p>High-level languages (<em>HL-languages</em> from now on) implement many
concepts which are not present at the machine code programming level.
Most outstanding features are:</p>
<ul class="simple">
<li><p>human readable form of numbers and strings <em>(like decimal, octal,
hexadecimal representations for numbers)</em>,</p></li>
<li><p>containers <em>(automatic allocation for places in the memory to hold,
access and name data)</em>,</p></li>
<li><p>expressions <em>(calculation formulas based on operators which have
precedences the way we are used to from mathematics)</em>,</p></li>
<li><p>constructs for repetitive execution <em>(conditional re-execution of
code parts)</em>,</p></li>
<li><p>functions,</p></li>
<li><p>facilities for data organization <em>(ability to define new data types
based on the primitive ones, organizing them in the memory in certain
layouts)</em>.</p></li>
</ul>
</div>
<div class="section" id="implementing-with-a-high-level-language-interpreter-vs-compiler">
<h3><span class="section-number">2.4.3. </span>Implementing with a High-level Language: Interpreter vs. Compiler<a class="headerlink" href="#implementing-with-a-high-level-language-interpreter-vs-compiler" title="Permalink to this headline">¶</a></h3>
<p>We can implement our solution in a high-level programming language in
two manners:</p>
<ol class="arabic simple">
<li><p><strong>Compilative Approach</strong>. In this approach, a translator, called
<em>compiler</em>, takes a high-level programming language program as input
and converts all actions in the program into a machine code program
(<a class="reference internal" href="#fig-ch2-compiler"><span class="std std-numref">Fig. 2.4.2</span></a>). The outcome is a machine code program
that can be run any time (by asking the OS to do so) and does the job
described in the high-level language program.</p></li>
</ol>
<p>Conceptually this is correct, but actually, this schema has another step
in-the-loop. The compiler produces an almost complete machine code with
some holes in it. These holes are about the parts of the code which is
not actually coded by the programmer, but filled in from a pre-created
machine code library (it is actually named as <em>library</em>). A program,
named <em>linker</em> fills those holes. The linker knows about the library and
patches in the parts of the code that are referenced by the programmer.</p>
<div class="figure align-default" id="id6">
<span id="fig-ch2-compiler"></span><a class="reference internal image-reference" href="../_images/ch2_compiler.png"><img alt="../_images/ch2_compiler.png" src="../_images/ch2_compiler.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-number">Fig. 2.4.2 </span><span class="caption-text">A program code in a high-level language is first translated into
machine understandable binary code (machine code) which is then
loaded and executed on the machine to obtain the result. [From: <a class="reference external" href="https://link.springer.com/book/10.1007/978-3-7091-1343-1">G.
Üçoluk, S. Kalkan, Introduction to Programming Concepts with Case
Studies in Python, Springer,
2012</a>]</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
<ol class="arabic simple" start="2">
<li><p><strong>Interpretive Approach</strong>. In this approach, a machine code program,
named as <em>interpreter</em>, when run, inputs and processes the high-level
program line by line (<a class="reference internal" href="#fig-ch2-interpreter"><span class="std std-numref">Fig. 2.4.3</span></a>). After taking
a line as input, the actions described in the line are <em>immediately</em>
executed; if the action is printing some value, the output is printed
right away; if it is an evaluation of a mathematical expression, all
values are substituted and at that very point-in-time, the expression
is evaluated to calculate the result. In other words, any action is
carried out immediately when the interpreter comes to its line in the
program. In practice, it is always possible to write down the program
lines into a file, and make the interpreter read the program lines
one by one from that file as well.</p></li>
</ol>
<div class="figure align-default" id="id7">
<span id="fig-ch2-interpreter"></span><a class="reference internal image-reference" href="../_images/ch2_interpreter.png"><img alt="../_images/ch2_interpreter.png" src="../_images/ch2_interpreter.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-number">Fig. 2.4.3 </span><span class="caption-text">Interpreted languages (e.g. Python) come with interpreters that
process and evaluate each action (statement) from the user on the run
and returns an answer. [From: <a class="reference external" href="https://link.springer.com/book/10.1007/978-3-7091-1343-1">G. Üçoluk, S. Kalkan, Introduction to
Programming Concepts with Case Studies in Python, Springer,
2012</a>]</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</div>
<p><strong>Which approach is better?</strong></p>
<p>Both approaches have their benefits. When a specific task is considered,
compilers generate fast executing machine codes compared to the same
task being carried out by an interpreter. On the other hand compilers
are unpleasant when trial-and-errors are possible while developing the
solution. Interpreters, on the other hand, allow making small changes
and the programmer receives immediate responses, which makes it easier
to observe intermediate results and adjust the algorithm accordingly.
However, interpreters are slower since they involve an interpretation
component while running the code. Sometimes this slowness is by a factor
of 20. Therefore, the interpretive approach is good for quick
implementations whereas using a compiler is good for computation-intense
big projects or time-tight tasks.</p>
</div>
<div class="section" id="programming-language-paradigms">
<h3><span class="section-number">2.4.4. </span>Programming-language Paradigms<a class="headerlink" href="#programming-language-paradigms" title="Permalink to this headline">¶</a></h3>
<p>As we mentioned before, there are more than 700 programming languages.
Certainly some are for academic purposes and some did not gain any
popularity. But there are about 20 programming languages which are
commonly used for writing programs. How do we choose one when
implementing our solution?</p>
<p>Picking a particular programming language is not just a matter of taste.
During the course of the evolution of the programming languages,
different strategies or world views about programming have also
developed. These world views are reflected in the programming languages.</p>
<p>For example, one world view regards the programming task as transforming
some initial data (the initial information that defines the problem)
into a final form (the data that is the answer to that problem) by
applying a sequence of functions. From this perspective, writing a
program consists of defining some functions which are then used in a
functional composition; a composition which, when applied to some
initial data, yields the answer to the problem.</p>
<p>This concept of world views are coined as <em>programming paradigms</em>. The
Oxford dictionary defines the word paradigm as follows:</p>
<blockquote>
<div><p><strong>paradigm</strong> <span class="math notranslate nohighlight">\(|\)</span>’parǝ,dïm<span class="math notranslate nohighlight">\(|\)</span></p>
<p><em>noun</em></p>
<p>A world view underlying the theories and methodology of a particular
scientific subject.</p>
</div></blockquote>
<p>Below is a list of some major paradigms:</p>
<ul class="simple">
<li><p><strong>Imperative</strong>: Is a paradigm where programming statements and their
composition directly map to the machine code segments, so that the
whole machine code is covered.</p></li>
<li><p><strong>Functional</strong>: In this paradigm, solving a programming task is to
construct a group of functions so that their ‘functional composition’
acting on the initial data produces the solution.</p></li>
<li><p><strong>Object oriented</strong>: In this paradigm the compulsory separation (due
to the von Neumann architecture) of algorithm from data is lifted,
and algorithm and data are reunited under an artificial computational
entity: <em>the object</em>. An object has algorithmic properties as well as
data properties.</p></li>
<li><p><strong>Logical-declarative</strong>: This is the most contrasting view compared
to the imperative paradigm. The idea is to represent logical and
mathematical relations among entities (as rules) and then ask an
inference engine for a solution that satisfies all rules. The
inference engine is a kind of ‘prover’, i.e. a program, that is
constructed by the inventor of the logical-declarative programming
language.</p></li>
<li><p><strong>Concurrent</strong>: A paradigm where independent computational entities
work towards the solution of a problem. For problems that can be
solved by a divide-and-conquer strategy, this paradigm is very
suitable.</p></li>
<li><p><strong>Event driven</strong>: This paradigm introduces the concept of events into
programming. Events are assumed to be asynchronous and they have
‘handlers’, i.e. programs that carry out the actions associated with
a particular event. Programming graphical user interfaces (GUIs) is
usually performed using event-driven languages: An event in a GUI is
generated e.g. when the user clicks the “Close” button, which
triggers the execution of a handler function that performs the
associated closing action.</p></li>
</ul>
<p>In contrary to the layman programmers’ assumption, these paradigms are
not mutually exclusive. Many paradigms can very well co-exist in a
programming language together. At a meta level, we can call them
‘orthogonal’ to each other. This is why we have so many programming
languages around. A language can provide imperative as well as
functional and object-oriented constructs. Then it is up to the
programmer to blend them in his or her particular program. As it is with
many ‘world views’ among humans, in the field of programming, fanaticism
exists too. You can meet individuals that do only functional programming
or object-oriented programming. We better consider them outliers.</p>
<p>Python, the subject language of this book, supports strongly the
imperative, functional and object-orient paradigms. It also provides
some functionality in other paradigms by some modules.</p>
</div>
</div>
<div class="section" id="introducing-python">
<h2><span class="section-number">2.5. </span>Introducing Python<a class="headerlink" href="#introducing-python" title="Permalink to this headline">¶</a></h2>
<p>After having provided background on the world of programming, let us
introduce Python: Although it is widely known to be a recent programming
language, Python’s design, by <a class="reference external" href="https://en.wikipedia.org/wiki/Guido_van_Rossum">Guido van
Rossum</a>, dates back
to 1980s, as a successor of the ABC programming language. The first
version was released in 1991 and with the second version released in
2000, it started gaining a wider interest from the community. After it
was chosen by some big IT companies as the main programming language,
Python became one of the most popular programming languages.</p>
<p>An important reason for Python’s wide acceptance and use is its design
principles. By design, Python is a programming language that is easier
to understand and to write but at the same time powerful, functional,
practical and fun. This has deep roots in its design philosophy (a.k.a.
<a class="reference external" href="https://en.wikipedia.org/wiki/Zen_of_Python">The Zen of Python</a>):</p>
<blockquote>
<div><p>“Beautiful is better than ugly. Explicit is better than implicit.
Simple is better than complex. Complex is better than complicated.
Readability counts. [… <em>there are 14 more</em>]”</p>
</div></blockquote>
<p>Python is multi-paradigm programming language, supporting imperative,
functional and object-oriented paradigms, although the last one is not
one of its strong suits, as we will see in Chapter 7. Thanks to its wide
acceptance especially in the open-source communities, Python comes with
or can be extended with an ocean of libraries for practically solving
any kind of task.</p>
<p>The word ‘python’ was chosen as the name for the programming language
not because of the snake species python but because of the comedy group
<a class="reference external" href="https://en.wikipedia.org/wiki/Monty_Python">Monty Python</a>. While van
Possum was developing Python, he read the scripts of Monty Python’s
Flying Circus and thought ‘python’ was <a class="reference external" href="https://docs.python.org/2/faq/general.html#why-is-it-called-python">“short, unique and
mysterious”</a>
for the new language. To make Python more fun to learn, earlier releases
heavily used phrases from Monty Python in example programming codes.</p>
<p>With version 3.9 being released in October 2020 as the latest version,
Python is one of the most popular programming languages in a wide
spectrum of disciplines and domains. With an active support from the
open-source community and big IT companies, this is not likely to change
in the near future. Therefore, it is in your best interest to get
familiar with Python if not excel in it.</p>
<p>This is how the Python interpreter looks like at a Unix terminal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python3
Python 3.8.5 (default, Jul 21 2020, 10:48:26)
[Clang 11.0.3 (clang-1103.0.32.62)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;
</pre></div>
</div>
<p>The three symbols <code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code> indicate that the interpreter is ready to
collect our computational demands, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">21</span><span class="o">+</span><span class="mi">21</span>
<span class="go">42</span>
</pre></div>
</div>
<p>where we asked what was <code class="docutils literal notranslate"><span class="pre">21+21</span></code> and Python responded with <code class="docutils literal notranslate"><span class="pre">42</span></code>,
which is one small step for a man but one giant leap for mankind.</p>
</div>
<div class="section" id="important-concepts">
<h2><span class="section-number">2.6. </span>Important Concepts<a class="headerlink" href="#important-concepts" title="Permalink to this headline">¶</a></h2>
<p>We would like our readers to have grasped the following crucial concepts
and keywords from this chapter:</p>
<ul class="simple">
<li><p>How we solve problems using computers.</p></li>
<li><p>Algorithms: What they are, how we write them and how we compare them.</p></li>
<li><p>The spectrum of programming languages.</p></li>
<li><p>Pros and cons of low-level and high-level languages.</p></li>
<li><p>Interpretive vs. compilative approach to programming.</p></li>
<li><p>Programming paradigms.</p></li>
</ul>
</div>
<div class="section" id="further-reading">
<h2><span class="section-number">2.7. </span>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>The World of Programming chapter available at:
<a class="reference external" href="https://link.springer.com/chapter/10.1007/978-3-7091-1343-1_1">https://link.springer.com/chapter/10.1007/978-3-7091-1343-1_1</a></p></li>
<li><p>Programming Languages:</p>
<ul>
<li><p>For a list of programming languages:
<a class="reference external" href="http://en.wikipedia.org/wiki/Comparison_of_programming_languages">http://en.wikipedia.org/wiki/Comparison_of_programming_languages</a></p></li>
<li><p>For a comparison of programming languages:
<a class="reference external" href="http://en.wikipedia.org/wiki/Comparison_of_programming_languages">http://en.wikipedia.org/wiki/Comparison_of_programming_languages</a></p></li>
<li><p>For more details: Daniel P. Friedman, Mitchell Wand, Christopher
Thomas Haynes: Essentials of Programming Languages, The MIT Press
2001.</p></li>
</ul>
</li>
<li><p>Programming Paradigms:</p>
<ul>
<li><p>Introduction: <a class="reference external" href="http://en.wikipedia.org/wiki/Programming_paradigm">http://en.wikipedia.org/wiki/Programming_paradigm</a></p></li>
<li><p>For a detailed discussion and taxonomy of the paradigms: P. Van
Roy, Programming Paradigm for Dummies: What Every Programmer
Should Know, New Computational Paradigms for Computer Music, G.
Assayag and A. Gerzso (eds.), IRCAM/Delatour France, 2009
<a class="reference external" href="http://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf">http://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf</a></p></li>
<li><p>Comparison between Paradigms:
<a class="reference external" href="http://en.wikipedia.org/wiki/Comparison_of_programming_paradigms">http://en.wikipedia.org/wiki/Comparison_of_programming_paradigms</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="exercise">
<h2><span class="section-number">2.8. </span>Exercise<a class="headerlink" href="#exercise" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Draw the flowchart for the following algorithm:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Step</span> <span class="mi">1</span><span class="p">:</span> <span class="n">Get</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">N</span> <span class="n">numbers</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">variable</span> <span class="n">named</span> <span class="n">Numbers</span>
<span class="n">Step</span> <span class="mi">2</span><span class="p">:</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">variable</span> <span class="n">named</span> <span class="n">Sum</span> <span class="k">with</span> <span class="n">initial</span> <span class="n">value</span> <span class="mi">0</span>
<span class="n">Step</span> <span class="mi">3</span><span class="p">:</span> <span class="n">For</span> <span class="n">each</span> <span class="n">number</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Numbers</span><span class="p">,</span> <span class="n">execute</span> <span class="n">the</span> <span class="n">following</span> <span class="n">line</span><span class="p">:</span>
<span class="n">Step</span> <span class="mi">4</span><span class="p">:</span>     <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">Add</span> <span class="n">i</span> <span class="n">to</span> <span class="n">Sum</span>
<span class="n">Step</span> <span class="mi">5</span><span class="p">:</span>     <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">Add</span> <span class="n">the</span> <span class="n">square</span> <span class="n">of</span> <span class="n">i</span> <span class="n">to</span> <span class="n">Sum</span>
<span class="n">Step</span> <span class="mi">5</span><span class="p">:</span> <span class="n">Divide</span> <span class="n">Sum</span> <span class="n">by</span> <span class="n">N</span>
</pre></div>
</div>
<ul class="simple">
<li><p>What is the complexity of Algorithm 1 (in Section 2.2)?</p></li>
<li><p>What is the complexity of the following algorithm?</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Step</span> <span class="mi">1</span><span class="p">:</span> <span class="n">Get</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">N</span> <span class="n">numbers</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">variable</span> <span class="n">named</span> <span class="n">Numbers</span>
<span class="n">Step</span> <span class="mi">2</span><span class="p">:</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">variable</span> <span class="n">named</span> <span class="n">Mean</span> <span class="k">with</span> <span class="n">initial</span> <span class="n">value</span> <span class="mi">0</span>
<span class="n">Step</span> <span class="mi">3</span><span class="p">:</span> <span class="n">For</span> <span class="n">each</span> <span class="n">number</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Numbers</span><span class="p">,</span> <span class="n">execute</span> <span class="n">the</span> <span class="n">following</span> <span class="n">line</span><span class="p">:</span>
<span class="n">Step</span> <span class="mi">4</span><span class="p">:</span>     <span class="n">Add</span> <span class="n">i</span> <span class="n">to</span> <span class="n">Mean</span>
<span class="n">Step</span> <span class="mi">5</span><span class="p">:</span> <span class="n">Divide</span> <span class="n">Mean</span> <span class="n">by</span> <span class="n">N</span>
<span class="n">Step</span> <span class="mi">6</span><span class="p">:</span> <span class="n">Initialize</span> <span class="n">a</span> <span class="n">variable</span> <span class="n">named</span> <span class="n">Std</span> <span class="k">with</span> <span class="n">value</span> <span class="mi">0</span>
<span class="n">Step</span> <span class="mi">7</span><span class="p">:</span> <span class="n">For</span> <span class="n">each</span> <span class="n">number</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Numbers</span><span class="p">,</span> <span class="n">execute</span> <span class="n">the</span> <span class="n">following</span> <span class="n">line</span><span class="p">:</span>
<span class="n">Step</span> <span class="mi">8</span><span class="p">:</span>    <span class="n">Add</span> <span class="n">the</span> <span class="n">square</span> <span class="n">of</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">Mean</span><span class="p">)</span> <span class="n">to</span> <span class="n">Std</span>
<span class="n">Step</span> <span class="mi">9</span><span class="p">:</span> <span class="n">Divide</span> <span class="n">Std</span> <span class="n">by</span> <span class="n">N</span> <span class="ow">and</span> <span class="n">take</span> <span class="n">its</span> <span class="n">square</span> <span class="n">root</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Assuming that a step of an algorithm takes 1 second, fill in the
following table for different algorithms for different input sizes
(<span class="math notranslate nohighlight">\(n\)</span>):</p></li>
</ul>
<center><table><tr><th><p>Input Size</p>
</th><th><p><span class="math notranslate nohighlight">\(\cal{O}(\log n)\)</span></p>
</th><th><p><span class="math notranslate nohighlight">\(\cal{O}(n)\)</span></p>
</th><th><p><span class="math notranslate nohighlight">\(\cal{O}(n \log n)\)</span></p>
</th><th><p><span class="math notranslate nohighlight">\(\cal{O}(n^2)\)</span></p>
</th><th><p><span class="math notranslate nohighlight">\(\cal{O}(n^3)\)</span></p>
</th><th><p><span class="math notranslate nohighlight">\(\cal{O}(2^n)\)</span></p>
</th><th><p><span class="math notranslate nohighlight">\(\cal{O}(n^n)\)</span></p>
</th></tr><tr><td><p><span class="math notranslate nohighlight">\(n=10^2\)</span></p>
</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><p><span class="math notranslate nohighlight">\(n=10^3\)</span></p>
</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><p><span class="math notranslate nohighlight">\(n=10^4\)</span></p>
</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><p><span class="math notranslate nohighlight">\(n=10^5\)</span></p>
</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></table></center><ul class="simple">
<li><p>Assume that we have a parser than can process and parse natural
language descriptions (without any syntactic restrictions) for
programming a computer. Given such a parser, do you think we would
use natural language to program computers? If no, why not?</p></li>
<li><p>For each situation below, try to identify which paradigm is more
suitable compared to the others:</p></li>
<li><p>Writing a program which should take an image as input, an RGB color
value and find all pixels in the image that match the given color.</p></li>
<li><p>Writing a theorem proving program.</p></li>
<li><p>Writing the auto pilot program flying an airplane.</p></li>
<li><p>Writing a document editing program as an alternative to Microsoft
Word.</p></li>
</ul>
</div>
</div>


        </div>
        <div class="side-doc-outline">
            <div class="side-doc-outline--content"> 
<div class="localtoc">
    <p class="caption">
      <span class="caption-text">Table Of Contents</span>
    </p>
    <ul>
<li><a class="reference internal" href="#">2. A Broad Look at Programming and Programming Languages</a><ul>
<li><a class="reference internal" href="#how-do-we-solve-problems-with-programs">2.1. How do we solve problems with programs?</a></li>
<li><a class="reference internal" href="#algorithm">2.2. Algorithm</a><ul>
<li><a class="reference internal" href="#how-to-write-algorithms">2.2.1. How to write algorithms</a></li>
<li><a class="reference internal" href="#how-to-compare-algorithms">2.2.2. How to compare algorithms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-representation">2.3. Data Representation</a></li>
<li><a class="reference internal" href="#the-world-of-programming-languages">2.4. The World of Programming Languages</a><ul>
<li><a class="reference internal" href="#low-level-languages">2.4.1. Low-level Languages</a></li>
<li><a class="reference internal" href="#high-level-languages">2.4.2. High-level Languages</a></li>
<li><a class="reference internal" href="#implementing-with-a-high-level-language-interpreter-vs-compiler">2.4.3. Implementing with a High-level Language: Interpreter vs. Compiler</a></li>
<li><a class="reference internal" href="#programming-language-paradigms">2.4.4. Programming-language Paradigms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#introducing-python">2.5. Introducing Python</a></li>
<li><a class="reference internal" href="#important-concepts">2.6. Important Concepts</a></li>
<li><a class="reference internal" href="#further-reading">2.7. Further Reading</a></li>
<li><a class="reference internal" href="#exercise">2.8. Exercise</a></li>
</ul>
</li>
</ul>

</div>
            </div>
        </div>

      <div class="clearer"></div>
    </div><div class="pagenation">
     <a id="button-prev" href="ch1_computer_organization.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="P">
         <i class="pagenation-arrow-L fas fa-arrow-left fa-lg"></i>
         <div class="pagenation-text">
            <span class="pagenation-direction">Previous</span>
            <div>1. Basic Computer Organization</div>
         </div>
     </a>
     <a id="button-next" href="ch3_data_representation.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="N">
         <i class="pagenation-arrow-R fas fa-arrow-right fa-lg"></i>
        <div class="pagenation-text">
            <span class="pagenation-direction">Next</span>
            <div>3. Representation of Data</div>
        </div>
     </a>
  </div>
        
        </main>
    </div>
  </body>
</html>
