<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    
    <title>1. Basic Computer Organization &#8212; Programming with Python for Engineers 0.0.1 documentation</title>

    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/d2l.css" />
    <link rel="stylesheet" href="../_static/material-design-lite-1.3.0/material.blue-deep_orange.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx_materialdesign_theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/fontawesome/all.css" type="text/css" />
    <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/d2l.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2. A Broad Look at Programming and Programming Languages" href="ch2_programming.html" />
    <link rel="prev" title="Preface" href="ch0_preface.html" /> 
  </head>
<body>
    <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header mdl-layout--fixed-drawer"><header class="mdl-layout__header mdl-layout__header--waterfall ">
    <div class="mdl-layout__header-row">
        
        <nav class="mdl-navigation breadcrumb">
            <a class="mdl-navigation__link is-active"><span class="section-number">1. </span>Basic Computer Organization</a>
        </nav>
        <div class="mdl-layout-spacer"></div>
        <nav class="mdl-navigation">
        
<form class="form-inline pull-sm-right" action="../search.html" method="get">
      <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right">
        <label id="quick-search-icon" class="mdl-button mdl-js-button mdl-button--icon"  for="waterfall-exp">
          <i class="material-icons">search</i>
        </label>
        <div class="mdl-textfield__expandable-holder">
          <input class="mdl-textfield__input" type="text" name="q"  id="waterfall-exp" placeholder="Search" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </div>
      </div>
      <div class="mdl-tooltip" data-mdl-for="quick-search-icon">
      Quick search
      </div>
</form>
        
<a id="button-show-source"
    class="mdl-button mdl-js-button mdl-button--icon"
    href="../_sources/chapters/ch1_computer_organization.rst.txt" rel="nofollow">
  <i class="material-icons">code</i>
</a>
<div class="mdl-tooltip" data-mdl-for="button-show-source">
Show Source
</div>
        </nav>
    </div>
    <div class="mdl-layout__header-row header-links">
      <div class="mdl-layout-spacer"></div>
      <nav class="mdl-navigation">
          
              <a  class="mdl-navigation__link" href="https://pp4e-book.github.io/pp4e-book.pdf">
                  <i class="fas fa-file-pdf"></i>
                  PDF
              </a>
          
              <a  class="mdl-navigation__link" href="https://github.com/pp4e-book/source">
                  <i class="fab fa-github"></i>
                  Github
              </a>
          
              <a  class="mdl-navigation__link" href="https://pp4e-book.github.io/chapters/all_notebooks.zip">
                  <i class="fas fa-download"></i>
                  All Notebooks
              </a>
          
              <a  class="mdl-navigation__link" href="https://ceng240.github.io/">
                  <i class="fas fa-user-graduate"></i>
                  Course
              </a>
      </nav>
    </div>
</header><header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../index.html">
              <img class="logo" src="../_static/logo-with-text.png" alt="Programming with Python for Engineers"/>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul>
<li class="toctree-l1"><a class="reference internal" href="ch0_preface.html">Preface</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. Basic Computer Organization</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch2_programming.html">2. A Broad Look at Programming and Programming Languages</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch3_data_representation.html">3. Representation of Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch4_dive_into_python.html">4. Dive into Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch5_conditional_and_repetitive.html">5. Conditional and Repetitive Execution</a></li>
</ul>

            </nav>
        
        </div>
    
</header>
        <main class="mdl-layout__content" tabIndex="0">

	<script type="text/javascript" src="../_static/sphinx_materialdesign_theme.js "></script>
    <header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../index.html">
              <img class="logo" src="../_static/logo-with-text.png" alt="Programming with Python for Engineers"/>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul>
<li class="toctree-l1"><a class="reference internal" href="ch0_preface.html">Preface</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. Basic Computer Organization</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch2_programming.html">2. A Broad Look at Programming and Programming Languages</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch3_data_representation.html">3. Representation of Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch4_dive_into_python.html">4. Dive into Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch5_conditional_and_repetitive.html">5. Conditional and Repetitive Execution</a></li>
</ul>

            </nav>
        
        </div>
    
</header>

    <div class="document">
        <div class="page-content" role="main">
        
  <div class="section" id="basic-computer-organization">
<h1><span class="section-number">1. </span>Basic Computer Organization<a class="headerlink" href="#basic-computer-organization" title="Permalink to this headline">¶</a><a href="https://colab.research.google.com/github/pp4e-book/pp4e-book.github.io/blob/master/chapters/ch1_computer_organization.ipynb" onclick="captureOutboundLink('https://colab.research.google.com/github/['pp4e-book/pp4e-book.github.io']/blob/master/chapters/ch1_computer_organization.ipynb'); return false;"> <button style="float:right", id="Colab" class="mdl-button mdl-js-button mdl-button--primary mdl-js-ripple-effect"> <i class=" fas fa-external-link-alt"></i> Colab </button></a><div class="mdl-tooltip" data-mdl-for="Colab"> Open the notebook in Colab</div></h1>
<p>In this chapter, we will provide an overview of the internals of a
modern computer. To do so, we will first describe a general architecture
on which modern computers are based. Then, we will study the main
components and the principles that allow such machines to function as
general purpose “calculators”.</p>
<div class="section" id="the-von-neumann-architecture">
<h2><span class="section-number">1.1. </span>The von Neumann Architecture<a class="headerlink" href="#the-von-neumann-architecture" title="Permalink to this headline">¶</a></h2>
<div class="section" id="john-von-neumann">
<h3><span class="section-number">1.1.1. </span>John von Neumann<a class="headerlink" href="#john-von-neumann" title="Permalink to this headline">¶</a></h3>
<center><table align="center" width="100%" style="word-wrap:break-word; table-layout:fixed; width:150px"><tr><td style="vertical-align: top; max-width:150px"><p>From: <a class="reference external" href="https://www.oxfordreference.com/view/10.1093/oi/authority.20110803120234729">Oxford
Reference</a></p>
<div class="docutils container">
<p>“Hungarian-born US mathematician, creator of the theory of games and
pioneer in the development of the modern computer. Born in Budapest,
the son of a wealthy banker, von Neumann was educated at the
universities of Berlin, Zürich, and Budapest, where he obtained his
PhD in 1926. After teaching briefly at the universities of Berlin and
Hamburg, von Neumann moved to the USA in 1930 to a chair in
mathematical physics at Princeton. In 1933, he joined the newly
formed Institute of Advanced Studies at Princeton as one of its
youngest professors. By this time he had already established a
formidable reputation as one of the most powerful and creative
mathematicians of his day. In 1925 he had offered alternative
foundations for set theory, while in his Mathematischen Grundlagen
der Quantenmechanik (1931) he removed many of the basic doubts that
had been raised against the coherence and consistency of quantum
theory. In 1944, in collaboration with Oskar Morgenstern (1902–77),
von Neumann published The Theory of Games and Economic Behaviour. A
work of great originality, it is reputed to have had its origins at
the poker tables of Princeton and Harvard. The basic problem was to
show whether it was possible to speak of rational behaviour in
situations of conflict and uncertainty as in, for example, a game of
poker or wage negotiations. In 1927 von Neumann proved the important
theorem that even in games that are not fully determined, safe and
rational strategies exist. With entry of the USA into World War II in
1941 von Neumann, who had become an American citizen in 1937, joined
the Manhattan project (for the manufacture of the atom bomb) as a
consultant. In 1943 he became involved at Los Alamos on the crucial
problem of how to detonate an atom bomb. Because of the enormous
quantity of computations involved, von Neumann was forced to seek
mechanical aid. Although the computers he had in mind could not be
made in 1945, von Neumann and his colleagues began to design Maniac I
(Mathematical analyser, numerical integrator, and computer). Von
Neumann was one of the first to see the value of a flexible stored
program: a program that could be changed quite easily without
altering the computer’s basic circuits. He went on to consider deeper
problems in the theory of logical automata and finally managed to
show that self-reproducing machines were theoretically possible. Such
a machine would need 200 000 cells and 29 distinct states. Having
once been caught up in affairs of state von Neumann found it
difficult to return to a purely academic life. Thereafter much of his
time was therefore spent, to the regret of his colleagues, advising a
large number of governmental and private institutions. In 1954 he was
appointed to the Atomic Energy Commission. Shortly after this, cancer
was diagnosed and he was forced to struggle to complete his last
work, the posthumously published The Computer and the Brain (1958).”</p>
</div>
</td><td><div class="figure align-default" id="id1">
<span id="fig-von-neumann"></span><a class="reference internal image-reference" href="../_images/ch1_von_neumann.jpg"><img alt="../_images/ch1_von_neumann.jpg" src="../_images/ch1_von_neumann.jpg" style="width: 200px;" /></a>
<p class="caption"><span class="caption-number">Fig. 1.1.1 </span><span class="caption-text">John von Neumann (1903 – 1957)</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
</td></tr></table></center></div>
<div class="section" id="components-of-the-von-neumann-architecture">
<h3><span class="section-number">1.1.2. </span>Components of the von Neumann Architecture<a class="headerlink" href="#components-of-the-von-neumann-architecture" title="Permalink to this headline">¶</a></h3>
<p>The von Neumann architecture (<a class="reference internal" href="#fig-ch4-cpu"><span class="std std-numref">Fig. 1.1.2</span></a>) defines the basic
structure, or outline, used in most computers today. Proposed in 1945 by
von Neumann, it consists of two distinct units: An <em>addressable memory</em>
and a <em>Central Processing Unit</em> (CPU). All the encoded actions and data
are stored together in the memory unit. The CPU, querying these actions,
the so-called <em>instructions</em>, executes them one by one, sequentially
(though, certain instructions may alter the course of execution order).</p>
<div class="figure align-default" id="id2">
<span id="fig-ch4-cpu"></span><a class="reference internal image-reference" href="../_images/ch1_CPU.png"><img alt="../_images/ch1_CPU.png" src="../_images/ch1_CPU.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-number">Fig. 1.1.2 </span><span class="caption-text">A block structure view of the von Neumann Architecture.</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>The CPU communicates with the memory via two sets of wires, namely the
<em>address bus</em> and the <em>data bus</em>, plus a single <em>R/W</em> wire
(<a class="reference internal" href="#fig-ch4-cpu"><span class="std std-numref">Fig. 1.1.2</span></a>). These busses consist of several wires and
carry binary information to/from the memory. Each wire in a bus carries
one bit of the information (either a zero (<code class="docutils literal notranslate"><span class="pre">0</span></code>) or a one (<code class="docutils literal notranslate"><span class="pre">1</span></code>)).
Today’s von Neumann architectures are working on electricity, and
therefore, these zeros and ones correspond to voltages. A one indicates
usually the presence of a 5V and a zero denotes the absence of it.</p>
</div>
</div>
<div class="section" id="the-memory">
<h2><span class="section-number">1.2. </span>The Memory<a class="headerlink" href="#the-memory" title="Permalink to this headline">¶</a></h2>
<p>The memory can be imagined as pigeon holes organized as rows
(<a class="reference internal" href="#fig-ch1-memory"><span class="std std-numref">Fig. 1.2.1</span></a>). Each row has eight pigeon holes, each
being able to hold a zero (<code class="docutils literal notranslate"><span class="pre">0</span></code>) or one (<code class="docutils literal notranslate"><span class="pre">1</span></code>) – in electronic terms,
each pigeon hole is capable of storing a voltage (can you guess what
type of an electronical component a pigeon hole is?). Each such row is
named to be of the size <em>byte</em>; i.e., a byte means 8 bits.</p>
<div class="figure align-default" id="id3">
<span id="fig-ch1-memory"></span><img alt="../_images/ch1_memory_layout.png" src="../_images/ch1_memory_layout.png" />
<p class="caption"><span class="caption-number">Fig. 1.2.1 </span><span class="caption-text">The memory is organized as a stack of rows such that each row has an
associated address.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>Each byte of the memory has a unique address. When the address input
(also called address bus – <a class="reference internal" href="#fig-ch4-cpu"><span class="std std-numref">Fig. 1.1.2</span></a>) of the memory is
provided a binary number, the memory byte that has this number as the
address becomes accessible through the data output (also called output
data bus). Based on W/R wire being set to Write (<code class="docutils literal notranslate"><span class="pre">1</span></code>) or Read (<code class="docutils literal notranslate"><span class="pre">0</span></code>),
the action that is carried out on the memory byte differs:</p>
<ul>
<li><div class="line-block">
<div class="line"><strong>W/R wire is set to WRITE (1)</strong> :</div>
<div class="line">The binary content on the input data bus is copied into the 8-bit
location whose address is provided on the address bus, the former
content is <em>overwritten</em>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>W/R wire is set to READ (0)</strong> :</div>
<div class="line">The data bus is set to a copy of the content of 8-bit location
whose address is provided on the address bus. The content of the
accessed byte is left intact.</div>
</div>
</li>
</ul>
<p>The information stored in this way at several addresses live in the
memory happily, until the power is turned off.</p>
<p>The memory is also referred as Random Access Memory (RAM). Some
important aspects of this type of memory have to be noted:</p>
<ul class="simple">
<li><p>Accessing any content in RAM, whether for reading or writing
purposes, is <em>only</em> possible when the content’s address is provided
to the RAM through the address bus.</p></li>
<li><p>Accessing any content takes exactly the same amount of time,
irrespective of the address of the content. In todays RAMs, this
access time is around 50 nanoseconds.</p></li>
<li><p>When a content is overwritten, it is gone forever and it is not
possible to undo this action.</p></li>
</ul>
<p>An important question is who sets the address bus and communicates
through the data bus (sends and receives bytes of data). As depicted in
<a class="reference internal" href="#fig-ch4-cpu"><span class="std std-numref">Fig. 1.1.2</span></a>, the CPU does. How this is done on the CPU side
will become clear in the next section.</p>
</div>
<div class="section" id="the-cpu">
<h2><span class="section-number">1.3. </span>The CPU<a class="headerlink" href="#the-cpu" title="Permalink to this headline">¶</a></h2>
<p>The Central Processing Unit, which can be considered as the ‘brain’ of a
computer, consists of the following units:</p>
<ul class="simple">
<li><p><strong>Control Unit (CU)</strong>, which is responsible for fetching instructions
from the memory, interpreting (‘decoding’) them and executing them.
After executing an instruction finishes, the control unit continues
with the next instruction in the memory. This “fetch-decode-execute”
cycle is constantly executed by the control unit.</p></li>
<li><p><strong>Arithmetic Logic Unit (ALU)</strong>, which is responsible for performing
arithmetic (addition, subtraction, multiplication, division) and
logic (less-than, greater-than, equal-to etc.) operations. CU
provides the necessary data to ALU and the type of operation that
needs to be performed, and ALU executes the operation.</p></li>
<li><p><strong>Registers</strong>, which are mainly storage units on the CPU for storing
the instruction being executed, the affected data, the outputs and
temporary values.</p></li>
</ul>
<p>The size and the quantity of the registers differ from CPU model to
model. They generally have size in the range of [2-64] bytes and most
registers on today’s most popular CPUs have size 64 bits (i.e. 8 bytes).
Their quantity is not high and in the range of [10-20]. The registers
can be broadly categorized into two: <em>Special Purpose Registers</em> and
<em>General Purpose Registers</em>.</p>
<p>Two special purpose registers are worth mentioning to understand how a
CPU’s Fetch-Decode-Execute cycle runs. The first is the so-called
<em>Program Counter</em> (PC) and the second is the <em>Instruction Register</em>
(IR).</p>
<ul class="simple">
<li><p><strong>Input/Output connections</strong>, which connect the CPU to the other
components in the computer.</p></li>
</ul>
</div>
<div class="section" id="the-fetch-decode-execute-cycle">
<h2><span class="section-number">1.4. </span>The Fetch-Decode-Execute Cycle<a class="headerlink" href="#the-fetch-decode-execute-cycle" title="Permalink to this headline">¶</a></h2>
<p>The CPU is in fact a <em>state machine</em>, a machine that has a
representation of its current <em>state</em>. The machine, being in a state,
reads the next instruction and executes the instruction according to its
current state. The state consists of what is stored in the registers.
Until it is powered off, the CPU follows the Fetch-Decode-Execute cycle
(<a class="reference internal" href="#fig-ch1-fetch-decode-execute"><span class="std std-numref">Fig. 1.4.1</span></a>) where each step of the cycle
is based on its state. The <em>control unit</em> is responsible for the
functioning of the cycle.</p>
<div class="figure align-default" id="id4">
<span id="fig-ch1-fetch-decode-execute"></span><a class="reference internal image-reference" href="../_images/ch1_fetch_decode_execute.png"><img alt="../_images/ch1_fetch_decode_execute.png" src="../_images/ch1_fetch_decode_execute.png" style="width: 300px;" /></a>
<p class="caption"><span class="caption-number">Fig. 1.4.1 </span><span class="caption-text">The CPU constantly follows the fetch-decode-execute cycle while the
computer is running a program.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<p>1- <strong>The Fetch Phase</strong></p>
<p>The cycle starts with the Fetch Phase. At the beginning of this phase,
the CPU has the address (the position in the memory) of the next
instruction in the PC (Program Counter) Register. During this phase, the
address bus is set to this address in the PC register and the R/W wire
is set to Read (0). The memory responds to this by providing the memory
content at the given address on the data bus.</p>
<p>How many bytes are sent through the data bus is architecture dependent.
Usually it is 4-8 bytes. These bytes are received into the IR
(Instruction Register).</p>
<p>2- <strong>The Decode Phase</strong></p>
<p>At the beginning of this phase, the IR is assumed to be holding the
current instruction. The content of the first part of the IR
electronically triggers some action. Every CPU has an electronically
built-in hard-wired instruction table in which every possible atomic
operation that the CPU can carry out has an associated binary code,
called <em>operation code</em> (opcode in short). This table differs from CPU
brand to brand.</p>
<p>There are three types of instructions:</p>
<ul class="simple">
<li><p><em>Data manipulation</em>: Arithmetic/Logic operations on/among registers,</p></li>
<li><p><em>Data transfer</em>: Memory-to-Register, Register-to-Memory,
Register-to-Register transfers,</p></li>
<li><p><em>Control flow of execution</em>: Instructions that stop execution, jump
to a different part of the memory for next instruction, instead of
the next one in the memory.</p></li>
</ul>
<p>Let us assume that our instruction looks like this:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Opcode</p></th>
<th class="head"><p>Effected data or address</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0001</p></td>
<td><p>0110</p></td>
</tr>
</tbody>
</table>
<p>This is an 8-byte instruction that has the first 4 bits as representing
the opcode. The designer could have designed the CPU such that the
opcode <code class="docutils literal notranslate"><span class="pre">0001</span></code> denotes an instruction for reading data from the memory,
writing data to the memory or adding the contents of the two registers
etc. The remaining four bits then contain the parameters of the
instruction, which are the data to be operated on, the address in the
memory or the codes of the registers etc.</p>
<p>Let us assume that this 8-bit example instruction (i.e. the opcode
<code class="docutils literal notranslate"><span class="pre">0001</span></code>) denotes an addition on two registers and that the remaining 4
bits encode the registers in question, with <code class="docutils literal notranslate"><span class="pre">01</span></code> denoting one register
and <code class="docutils literal notranslate"><span class="pre">10</span></code> the other register. Prior to the instruction, we can assume
the two registers to contain integers, and after the instruction is
executed, one of the registers will be incremented by the amount of the
other (by means of integer addition).</p>
<p>Although this was a simple and hypothetical example, it illustrates how
modern CPUs can decode an instruction and decipher its elements. Though,
the length of an instruction and the variety of instructions are clearly
different.</p>
<p>3- <strong>The Execute Phase</strong></p>
<p>As the name implies, the electronically activated and initialized
circuitry carries out the instruction in this phase. Depending on the
instruction, the registers, the memory or other components are effected.
When the instruction completes, the PC is updated by one unless it was a
control flow changing instruction in which case the PC is updated to the
to-be-jumped address in the memory (in some designs, the PC can be
updated in the fetch phase, after fetching the instruction). Not all
instructions take the same amount of time to be carried out. Floating
point division, for example, takes much more time compared to others.</p>
<p>A CPU goes through the <em>Fetch-Decode-Execute</em> cycle until it is powered
off. What happens at the very beginning? The electronics of the CPU is
manufactured such that, when powered up, the PC register has a very
fixed content. Therefore, the first instruction is always fetched from a
certain position.</p>
<p>An intelligent question would be “when does the CPU jump from one state
to another?”. One possible answer is: whenever the previous state is
completed electronically, a transition to the next state is performed.
Interestingly, this is not true. The reality is that there is an
external input to the CPU from which electronic pulses are fed. This
input is called the <em>system clock</em> and each period of it is named as a
<em>clock cycle</em>. The best performance would be that each phase of the
fetch-decode-execute cycle is completed in one-and-only-one clock cycle.
On modern CPUs, this is true for addition instruction, for example. But
there are instructions (like floating point division) which take about
40 clock cycles.</p>
<p>What is length of a clock cycle? CPUs are marked with their <em>clock
frequency</em>. For example, Intel’s latest processor, i9, has a maximal
clock frequency of 5GHz (that is <span class="math notranslate nohighlight">\(5\times 10^9\)</span> pulses per
second). So, since <span class="math notranslate nohighlight">\(\mbox{(period)} = 1/\mbox{(frequency)}\)</span>, for
this processor a clock cycle is 200 pico seconds. This is such a short
time that light would travel only 6 cm.</p>
<p>A modern CPU has many more features and functional components:
<em>interrupts, ports, various levels of caches</em> are a few of them. To
cover them is certainly out of the scope of this course material.</p>
</div>
<div class="section" id="the-stored-program-concept">
<h2><span class="section-number">1.5. </span>The Stored Program Concept<a class="headerlink" href="#the-stored-program-concept" title="Permalink to this headline">¶</a></h2>
<p>In order for the CPU to compute something, the corresponding
instructions to do the computation have to be placed into the memory
(how this is achieved will become clear in the next chapter). These
instructions and data that perform a certain task are called a <em>Computer
Program</em>. The idea of storing a computer program into the memory to be
executed is coined as the <em>Stored Program</em> Concept.</p>
<p>What does a stored program look like? Below you see a real extract from
the memory, a program that multiplies two integer numbers sitting in two
different locations in the memory and stores the result in another
memory location (to save space consecutive 8 bytes in the memory are
displayed in a row, the next row displays the next 8 bytes):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">01010101</span> <span class="mi">01001000</span> <span class="mi">10001001</span> <span class="mi">11100101</span> <span class="mi">10001011</span> <span class="mi">00010101</span> <span class="mi">10110010</span> <span class="mi">00000011</span>
<span class="mi">00100000</span> <span class="mi">00000000</span> <span class="mi">10001011</span> <span class="mi">00000101</span> <span class="mi">10110000</span> <span class="mi">00000011</span> <span class="mi">00100000</span> <span class="mi">00000000</span>
<span class="mi">00001111</span> <span class="mi">10101111</span> <span class="mi">11000010</span> <span class="mi">10001001</span> <span class="mi">00000101</span> <span class="mi">10111011</span> <span class="mi">00000011</span> <span class="mi">00100000</span>
<span class="mi">00000000</span> <span class="mi">10111000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">11001001</span> <span class="mi">11000011</span>
<span class="o">...</span>
<span class="mi">11001000</span> <span class="mi">00000001</span> <span class="mi">00000000</span> <span class="mi">00000000</span>  <span class="mi">00000000</span> <span class="mi">00000000</span>
</pre></div>
</div>
<p>Unless you have a magical talent, this should not be understandable to
you. It is difficult because it is just a sequence of bytes. Yes, the
first byte is presumably an instruction, but what is it? Furthermore,
since we do not know what it is, we do not know whether it is followed
by some data or not, so we cannot say where the second instruction
starts. However, the CPU for which these instructions were written for
would know this, hard-wired in its electronics.</p>
<p>When a programmer wants to write a program at this level, i.e. in terms
of binary CPU instructions and binary data, s/he has to understand and
know each instruction the CPU can perform, should be able to convert
data to some internal format, to make a detailed memory layout on paper
and then to start writing down each bit of the memory. This way of
programming is an extremely painful job; though it is possible, it is
impractical.</p>
<p>Alternatively, consider the text below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>main:
       pushq   %rbp
       movq    %rsp, %rbp
       movl    alice(%rip), %edx
       movl    bob(%rip), %eax
       imull   %edx, %eax
       movl    %eax, carol(%rip)
       movl    $0, %eax
       leave
       ret
alice:
       .long   123
bob:
       .long   456
</pre></div>
</div>
<p>Though <code class="docutils literal notranslate"><span class="pre">pushq</span></code> and <code class="docutils literal notranslate"><span class="pre">moveq</span></code> are not immediately understandable, the
rest of the text provides some hints. <code class="docutils literal notranslate"><span class="pre">alice</span></code> and <code class="docutils literal notranslate"><span class="pre">bob</span></code> must be some
programmer’s name invention, e.g. denoting variables with values <code class="docutils literal notranslate"><span class="pre">123</span></code>
and <code class="docutils literal notranslate"><span class="pre">456</span></code> respectively; <code class="docutils literal notranslate"><span class="pre">imull</span></code> must have something to do with
‘multiplication’, since only registers can be subject to arithmetic
operations; <code class="docutils literal notranslate"><span class="pre">%edx</span></code> and <code class="docutils literal notranslate"><span class="pre">%eax</span></code> must be some denotation used for
registers; having uncovered this, <code class="docutils literal notranslate"><span class="pre">movl</span></code>s start to make some sense:
they are some commands to move around data… and so on. Even without
knowing the instruction set, with a small brainstorming we can uncover
the action sequence.</p>
<p>This text is an example <em>assembly</em> program. A human invented denotation
for instructions and data. An important piece of knowledge is that each
line of the assembler text corresponds to a single instruction. This
assembly text is so clear that even manual conversion to the cryptic
binary code above is feasible. Form now on, we will call the binary code
program as a <em>Machine Code Program</em> (or simply the <em>machine code</em>).</p>
<p>How do we automatically obtain machine codes from assembly text? We have
machine code programs that convert the assembly text into machine code.
They are called <em>Assemblers</em>.</p>
<p>Despite making programming easier for programmers, compared to machine
codes, even assemblers are insufficient for efficient and fast
programming. They lack some high-level constructs and tools that are
necessary for solving problems easier and more practical. Therefore
higher level languages that are much easier to read and write compared
to assembly are invented.</p>
<p>We will cover the spectrum of programming languages in more detail in
the next chapter.</p>
</div>
<div class="section" id="pros-and-cons-of-the-von-neuman-architecture">
<h2><span class="section-number">1.6. </span>Pros and Cons of the von Neuman Architecture<a class="headerlink" href="#pros-and-cons-of-the-von-neuman-architecture" title="Permalink to this headline">¶</a></h2>
<p>The von Neumann architecture has certain advantages and disadvantages:</p>
<p><strong>Advantages</strong></p>
<ul class="simple">
<li><p>CPU retrieves data and instruction in the same manner from a single
memory device. This simplifies the design of the CPU.</p></li>
<li><p>Data from input/output (I/O) devices and from memory are retrieved in
the same manner. This is achieved by mapping the device communication
electronically to some address in the memory.</p></li>
<li><p>The programmer has a considerable control of the memory organization.
So, s/he can optimize the memory usage to its full extent.</p></li>
</ul>
<p><strong>Disadvantages</strong></p>
<ul class="simple">
<li><p>Sequential instruction processing nature makes parallel
implementations difficult. Any parallelization is actually a quick
sequential change in tasks.</p></li>
<li><p>The famous <em>“Von Neumann bottleneck”</em> : Instructions can only be
carried out one at a time and sequentially.</p></li>
<li><p>Risk of an instruction being unintentionally overwritten due to an
error in the program.</p></li>
</ul>
<p>An alternative to the von Neumann Architecture is the <a class="reference external" href="https://en.wikipedia.org/wiki/Harvard_architecture">Harvard
Architecture</a>
which could not resist the test of time due to crucial disadvantages
compared to the von Neumann architecture.</p>
</div>
<div class="section" id="peripherals-of-a-computer">
<h2><span class="section-number">1.7. </span>Peripherals of a computer<a class="headerlink" href="#peripherals-of-a-computer" title="Permalink to this headline">¶</a></h2>
<p>Though it is somewhat contrary to your expectation, any device outside
of the von Neumann structure, namely the CPU and the Memory, is a
<em>peripheral</em>. In this aspect, even the keyboard, the mouse and the
display are peripherals. So are the USB and ethernet connections and the
internal hard disk. Explaining the technical details of how those
devices are connected to the von Neumann architecture is out of the
scope of this book. Though, we can summarize it in a few words.</p>
<p>All devices are electronically listening to the busses (the address and
data bus) and to a wire running out of the CPU (which is not pictured
above) which is 1 or 0. This wire is called the <em>port_io</em> line and tells
the memory devices as well as to any other device that listens to the
busses whether the CPU is talking to the (real) memory or not. If it is
talking to the memory all the other listeners keep quiet. But if the
port_io line is 1, meaning the CPU doesn’t talk to the memory but to the
device which is electronically sensitive to that specific address that
was put on the address bus (by the CPU), then that device jumps up and
responds (through the data bus). The CPU can send as well as receive
data from that particular device. A computer has some precautions to
prevent address clashes, i.e. two devices responding to the same address
information in port_io.</p>
<p>Another mechanism aids communication requests initiated from the
peripherals. Of course it would be possible for the CPU from time to
time stop and do a port_io on all possible devices, asking them for any
data they want to send in. This technique is called <em>polling</em> and is
extremely inefficient for devices that send asynchronous data (data that
is send in irregular intervals): You cannot know when there will be a
keyboard entry so, in polling, you have to ask very frequently the
keyboard device for the existence of any data. Instead of dealing with
the inefficiency of polling, another mechanism is built into the CPU.
The interrupt mechanism is an electronic circuitry of the CPU which has
inlets (wires) connected to the peripheral devices. When a device wants
to communicate with (send or receive some data to/from) the CPU they
send a signal (1) from that specific wire. This gets the attention of
the CPU, the CPU stops what it is doing at a convenient point in time,
and asks the device for a port_io. So the device gets a chance to
send/receive data to/from the CPU.</p>
</div>
<div class="section" id="the-running-of-a-computer">
<h2><span class="section-number">1.8. </span>The running of a computer<a class="headerlink" href="#the-running-of-a-computer" title="Permalink to this headline">¶</a></h2>
<p>When you power on a computer, it first goes through a start-up process
(also called booting), which, after performing some routine checks,
loads a program from your disk called Operating System.</p>
<div class="section" id="start-up-process">
<h3><span class="section-number">1.8.1. </span>Start up Process<a class="headerlink" href="#start-up-process" title="Permalink to this headline">¶</a></h3>
<p>At the core of a computer is the von Neumann architecture. But how a
machine code finds its way into the memory, gets settled there, so that
the CPU starts executing it, is still unclear.</p>
<p>When you buy a brand new computer and turn it on for the first time, it
does some actions which are traceable on its display. Therefore, there
must be a machine code in a memory which, even when the power is off,
does not lose its content, very much like a flash drive. It is
electronically located exactly at the address where the CPU looks for
its first instruction. This memory, with its content, is called Basic
Input Output System, or in short BIOS. In the former days, the BIOS was
manufactured as write-only-once. To change the program, a chip had to be
replaced with a new one. The size of the BIOS of the first PCs was 16KB,
nowadays it is about 1000 times larger, 16MB.</p>
<p>When you power up a PC the BIOS program will do the following in
sequence:</p>
<ul class="simple">
<li><p>Power-On Self Test, abbreviated as POST, which determines whether the
CPU and the memory are intact, identifies and if necessary,
initializes devices like the video display card, keyboard, hard disk
drive, optical disc drive and other basic hardware.</p></li>
<li><p>Looking for an <em>operating system</em> (OS): The BIOS program goes through
storage devices (e.g. hard disk, floppy disk, USB disk, CD-DVD drive,
etc.) connected to the computer in a predefined order (this order is
generally changeable by the user) and looks for and settles for the
first operating system that it can find. Each storage device has a
small table at the beginning part of the device, called the Master
Boot Record (MBR), which contains a short machine code program to
load the operating system if there is one.</p></li>
<li><p>When BIOS finds such a storage device with an operating system, it
loads the content of the MBR into the memory and starts executing it.
This program loads the actual operating system and then runs it.</p></li>
</ul>
</div>
<div class="section" id="the-operating-system">
<h3><span class="section-number">1.8.2. </span>The Operating System<a class="headerlink" href="#the-operating-system" title="Permalink to this headline">¶</a></h3>
<p>The operating system is a program that, after being loaded into the
memory, manages resources and services like the use of memory, the CPU
and the devices. It essentially hides the internal details of the
hardware and makes the ugly binary machine understandable and manageable
to us.</p>
<p>An OS has the following responsibilities:</p>
<ul>
<li><p><strong>Memory Management</strong>: Refers to the management of the memory
connected to the CPU. In modern computers, there is more than one
machine code program loaded into the memory. Some programs are
initiated by the user (like a browser, document editor, Word, music
player, etc.) and some are initiated by the operating system. The CPU
switches very fast from one program (this is called a <em>process</em>) in
the memory to another. The user (usually) does not feel the
switching. The memory manager keeps track of the space allocated by
processes in the memory. When a new program (process) is being
started, it has to be placed into the memory. The memory manager
decides where it is going to be placed. Of course, when a process
ends, the place in the memory occupied by the process has to be
reclaimed; that is the memory manager’s job. It is also possible
that, while running, a process demands additional space in the memory
(e.g. a photoshop-like program needs more space for a newly opened
JPG image file) then the process makes this demand to the memory
manager, which grants it or denies it.</p></li>
<li><p><strong>Process (Time) Management</strong>: As said above, a modern memory
generally contains more than one machine code program. An electronic
mechanism forces the CPU to switch to the <em>Time Manager</em> component of
the OS. At least 20 times a second, the time manager is invoked to
make a decision on behalf of the CPU: Which of the processes that sit
in the memory will be run during the next period? When a process gets
the turn, the current state of the CPU (the contents of all
registers) is saved to some secure position in the memory, in
association to the last executing process. From that secure position,
the last saved state information which going to take the turn is
found and the CPU is set to that state. Then the CPU, for a period of
time executes that process. At the end of that period, the CPU
switches over to the time manager and the time manager makes a
decision for the next period. Which process will get the turn? And so
on. This decision making is a complex task. Still there are
Ph.D. level research going on on this subject. The time manager
collects some statistics about each individual process and its system
resource utilization. Also there is the possibility that a process
has a high priority associated due to several reasons. The time
manager has to solve a kind of optimization problem under some
constraints. As mentioned, this is a complex task and a hidden
quality factor of an OS.</p></li>
<li><p><strong>Device Management</strong>: All external devices of a computer have a
software plug-in to the operating system. An operating system has
some standardized demands from devices and these software plug-ins
implement these standardized functionality. This software is usually
provided by the device manufacturer and is loaded into the operating
system as a part of the device installing process. These plug-ins are
named as <em>device drivers</em>.</p>
<p>An Operating System performs device communication by means of these
drivers. It does the following activities for device management:</p>
<ul class="simple">
<li><p>Keeps tracks of all devices’ status.</p></li>
<li><p>Decides which process gets access to the device when and for how
long.</p></li>
<li><p>Implements some intelligent caching, if possible, for the data
communication with the device.</p></li>
<li><p>De-allocates devices.</p></li>
</ul>
</li>
<li><p><strong>File Management</strong>: A computer is basically a data processing
machine. Various data are produced or used for very diverse purposes.
Textual, numerical, audio-visual data are handled. Handling data also
includes <em>storing</em> and <em>retrieving</em> it on some external recording
device. Examples for such recording devices are hard disks, flash
drives, CDs and DVDs. Data is stored on these devices as files. A
<em>file</em> is a persistent piece of information that has a name, some
meta data (e.g. information about the owner, the creation time, size,
content type, etc.) and the data.</p>
<p>The organizational mechanism for how files are stored on devices is
called the <em>file system</em>. There are various alternatives to do this.
FAT16, FAT32, NTFS, EXT2, EXT3, ExFAT, HFS+ are a few of about a
hundred (actually the most common ones). Each has its own pros and
cons as far as <em>max allowed file size, security, robustness
(repairability), extensibility, metadata, lay out policies</em> and some
other aspects are concerned. Files are most often managed in a
hierarchy. This is achieved by a concept of <em>directories</em> or
<em>folders</em>. On the surface (as far as the user sees them), a file
system usually consist of files separated into directories where
directories can contain files or other directories.</p>
<p>The file manager is responsible for creation &amp; initialization of a
file system, inclusion and removal of devices from this system and
management of all sorts of changes in the file system: Creation,
removal, copying of files and directories, dynamically assigning
access rights for files and directories to processes etc.</p>
</li>
<li><p><strong>Security</strong>: This is basically for the maintenance of the computer’s
integrity, availability, and confidentiality. The security of a
computer exists at various layers such as:</p>
<ul class="simple">
<li><p>maintaining the physical security of the computer system,</p></li>
<li><p>the security of the information the system is in hold of, and</p></li>
<li><p>the security of the network to which the computer is connected.</p></li>
</ul>
<p>In all of these, the operating system plays a vital role in keeping
the security. Especially the second item is where the operating
system is involved at most. Information, as you know by now, is
placed in the computer in two locations. The internal memory and the
external storage devices. The internal memory is in hold of the
processes and the processes should not interfere with each other
(unless specifically intended). Actually in a modern day computer,
there can be more than one user working at the same time on the
computer. Their processes running in the memory as well as their
files being on the file system must remain extremely private and
separate. Even their existence has to be hidden from every other
user.</p>
<p>Computers are connected and more and more integrated in a global
network. This integration is done on a spectrum of interactions. In
the extreme case, a computer can be solely controlled over the
network. Of course this is done by supplying some credentials but, as
you would guess, such a system is prone to malicious attacks. An
operating system has to take measures to protect the computer system
from such harms. Sometimes it is the case that bugs of the OS are
discovered and exploited in order to breach security.</p>
</li>
<li><p><strong>User Interface</strong>: As the computer’s user, when you want to do
anything you do this by ordering the operating system to do it.
Starting/terminating a program, exploring or modifying the file
system, installing/uninstalling a new device are all done by
“talking” to the operating system. For this purpose, an OS provides
an interface, coined as the <em>user interface</em>. In the older days, this
was done by typing some cryptic commands into a typewriter at a
console device. Over the years, the first computer with a <em>Graphical
User Interface (GUI)</em> emerged. A GUI is a visual interface to the
user where the screen can host several windows each dedicated to a
different task. Elements of the operating system (processes, files,
directories, devices, network communications) and their status are
symbolized by icons and the interactions are mostly via moving and
clicking a pointing device which is another icon (usually a movable
arrow) on the screen. The <a class="reference external" href="https://github.com/sinankalkan/CENG240/blob/master/figures/XeroxAlto.jpg?raw=true">Xerox
Alto</a>
introduced on March 1973 was the first computer that had a GUI. The
first personal computer with a GUI was <a class="reference external" href="https://github.com/sinankalkan/CENG240/blob/master/figures/AppleLisa.jpg?raw=true">Apple
Lisa</a>,
introduced in 1983 with a price of $10,000. Almost three years later,
by the end of 1985, Microsoft released its first OS with a GUI:
Windows 1.0. The archaic console typing still exists, in the form a
type-able window, called terminal, which is still very much favoured
among programming professionals because it provides more control for
the OS.</p></li>
</ul>
</div>
</div>
<div class="section" id="important-concepts">
<h2><span class="section-number">1.9. </span>Important Concepts<a class="headerlink" href="#important-concepts" title="Permalink to this headline">¶</a></h2>
<p>We would like our readers to have grasped the following crucial concepts
and keywords from this chapter:</p>
<ul class="simple">
<li><p>The von Neumann Architecture.</p></li>
<li><p>The interaction between the CPU and the memory via address, R/W and
data bus lines.</p></li>
<li><p>The crucial components on the CPU: The control unit, the arithmetic
logic unit and the registers.</p></li>
<li><p>The fetch-decode-execute cycle.</p></li>
<li><p>The stored program concept.</p></li>
<li><p>Operating system and its responsibilities.</p></li>
</ul>
</div>
<div class="section" id="further-reading">
<h2><span class="section-number">1.10. </span>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Computer Architectures:</p>
<ul>
<li><p>Von Neumann Architecture:
<a class="reference external" href="http://en.wikipedia.org/wiki/Von_Neumann_architecture">http://en.wikipedia.org/wiki/Von_Neumann_architecture</a></p></li>
<li><p>Harvard Architecture:
<a class="reference external" href="http://en.wikipedia.org/wiki/Harvard_architecture">http://en.wikipedia.org/wiki/Harvard_architecture</a></p></li>
<li><p>Harvard vs. Von Neumann Architecture:
<a class="reference external" href="http://www.pic24micro.com/harvard_vs_von_neumann.html">http://www.pic24micro.com/harvard_vs_von_neumann.html</a></p></li>
<li><p>Quantum Computer: <a class="reference external" href="http://en.wikipedia.org/wiki/Quantum_computer">http://en.wikipedia.org/wiki/Quantum_computer</a></p></li>
<li><p>Chemical Computer: <a class="reference external" href="http://en.wikipedia.org/wiki/Chemical_computer">http://en.wikipedia.org/wiki/Chemical_computer</a></p></li>
<li><p>Non-Uniform Memory Access Computer:
<a class="reference external" href="http://en.wikipedia.org/wiki/Non-Uniform_Memory_Access">http://en.wikipedia.org/wiki/Non-Uniform_Memory_Access</a></p></li>
</ul>
</li>
<li><p>Running a computer:</p>
<ul>
<li><p>Booting a computer: <a class="reference external" href="https://en.wikipedia.org/wiki/Booting">https://en.wikipedia.org/wiki/Booting</a></p></li>
<li><p>History of operating systems:
<a class="reference external" href="https://en.wikipedia.org/wiki/History_of_operating_systems">https://en.wikipedia.org/wiki/History_of_operating_systems</a></p></li>
<li><p>Operating systems: <a class="reference external" href="https://en.wikipedia.org/wiki/Operating_system">https://en.wikipedia.org/wiki/Operating_system</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="exercises">
<h2><span class="section-number">1.11. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>To gain more insight, play around with the von Neumann machine
simulator at <a class="reference external" href="http://vnsimulator.altervista.org">http://vnsimulator.altervista.org</a></p></li>
<li><p>Using Google and the manufacturer’s web site, find the following
information for your desktop/laptop:</p>
<ul>
<li><p>Memory (RAM) size</p></li>
<li><p>CPU type and Clock frequency</p></li>
<li><p>Data bus size</p></li>
<li><p>Address bus size</p></li>
<li><p>Size of the general purpose registers of the CPU</p></li>
<li><p>Harddisk or SSD size and random access time</p></li>
</ul>
</li>
</ul>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Opcode</p></th>
<th class="head"><p>Affected address</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0001</p></td>
<td><p>0100</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Assume that we have a CPU that can execute instructions with the
format and size given above.</p>
<ul>
<li><p>What is the number of different instructions that this CPU can
decode?</p></li>
<li><p>What is the maximum number of rows in the memory that can be
addressed by this CPU?</p></li>
</ul>
</li>
</ul>
</div>
</div>


        </div>
        <div class="side-doc-outline">
            <div class="side-doc-outline--content"> 
<div class="localtoc">
    <p class="caption">
      <span class="caption-text">Table Of Contents</span>
    </p>
    <ul>
<li><a class="reference internal" href="#">1. Basic Computer Organization</a><ul>
<li><a class="reference internal" href="#the-von-neumann-architecture">1.1. The von Neumann Architecture</a><ul>
<li><a class="reference internal" href="#john-von-neumann">1.1.1. John von Neumann</a></li>
<li><a class="reference internal" href="#components-of-the-von-neumann-architecture">1.1.2. Components of the von Neumann Architecture</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-memory">1.2. The Memory</a></li>
<li><a class="reference internal" href="#the-cpu">1.3. The CPU</a></li>
<li><a class="reference internal" href="#the-fetch-decode-execute-cycle">1.4. The Fetch-Decode-Execute Cycle</a></li>
<li><a class="reference internal" href="#the-stored-program-concept">1.5. The Stored Program Concept</a></li>
<li><a class="reference internal" href="#pros-and-cons-of-the-von-neuman-architecture">1.6. Pros and Cons of the von Neuman Architecture</a></li>
<li><a class="reference internal" href="#peripherals-of-a-computer">1.7. Peripherals of a computer</a></li>
<li><a class="reference internal" href="#the-running-of-a-computer">1.8. The running of a computer</a><ul>
<li><a class="reference internal" href="#start-up-process">1.8.1. Start up Process</a></li>
<li><a class="reference internal" href="#the-operating-system">1.8.2. The Operating System</a></li>
</ul>
</li>
<li><a class="reference internal" href="#important-concepts">1.9. Important Concepts</a></li>
<li><a class="reference internal" href="#further-reading">1.10. Further Reading</a></li>
<li><a class="reference internal" href="#exercises">1.11. Exercises</a></li>
</ul>
</li>
</ul>

</div>
            </div>
        </div>

      <div class="clearer"></div>
    </div><div class="pagenation">
     <a id="button-prev" href="ch0_preface.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="P">
         <i class="pagenation-arrow-L fas fa-arrow-left fa-lg"></i>
         <div class="pagenation-text">
            <span class="pagenation-direction">Previous</span>
            <div>Preface</div>
         </div>
     </a>
     <a id="button-next" href="ch2_programming.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="N">
         <i class="pagenation-arrow-R fas fa-arrow-right fa-lg"></i>
        <div class="pagenation-text">
            <span class="pagenation-direction">Next</span>
            <div>2. A Broad Look at Programming and Programming Languages</div>
        </div>
     </a>
  </div>
        
        </main>
    </div>
  </body>
</html>
